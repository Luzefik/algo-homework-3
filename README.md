# [Домашня робота №3](https://github.com/Luzefik/algo-homework-3)

**Автор:** Кульбаба Андрій  
**Варіант:** 6  


**Дано:** Біпартитний граф $G = (U \cup W, E)$.  
**Потрібно:** Розфарбувати ребра в мінімальну кількість кольорів так, щоб жодні два суміжні ребра не мали однакового кольору.  
**Вхідні дані:** Множини вершин $U$ і $W$, список ребер.  
**Вихідні дані:** Для кожного ребра — номер кольору; також вивести загальну кількість використаних кольорів.

**Мова програмування:** C++

## Теоретичні відомості

Розв'язання цієї задачі зводиться до використання **теореми Кеніга** про реберне розфарбування. Теорема стверджує, що для будь-якого двочасткового графа хроматичний індекс $\chi'(G)$ (мінімальна кількість кольорів, необхідна для розфарбування ребер) дорівнює максимальному степеню вершини в графі $\Delta(G)$.

## Алгоритм та реалізація

Пошук та оптимізація реалізовані за допомогою жадібного алгоритму з використанням **ланцюгів Кемпе**.

### Логіка алгоритму

1.  **Жадібний крок:** Беремо чергове ребро $(u, v)$.
    * Перевіряємо, які кольори вільні у вершини $u$.
    * Перевіряємо, які кольори вільні у вершини $v$.
    * Якщо є спільний вільний колір — фарбуємо ребро в нього.

2.  **Вирішення конфліктів (Ланцюг Кемпе):**
    * Якщо спільного вільного кольору немає, припустимо:
        * У вершини $u$ вільний колір **A**, але він зайнятий у $v$.
        * У вершини $v$ вільний колір **B**, але він зайнятий у $u$.
    * **Ідея:** Необхідно звільнити колір **A** біля вершини $v$.
    * Для цього запускаємо [Ланцюг Кемпе](https://en.wikipedia.org/wiki/Kempe_chain) з вершини $v$. Ми проходимо по ребрах, які чергують кольори **A** та **B** ($A-B-A-B...$), і змінюємо їх місцями ($A \to B, B \to A$).
    * Оскільки граф двочастковий, цей шлях не може утворити непарний цикл і повернутися до $u$ з "неправильним" кольором.
    * Після перефарбування ланцюга колір **A** біля вершини $v$ стає вільним. Тепер ми можемо пофарбувати початкове ребро $(u, v)$ у колір **A**.

### Деталі реалізації (C++)

У файлі `main.cpp` створено клас `Graph`. Для представлення графа використано матрицю "Вершина-Колір".

Формально: `M[u][c] = v`, де:
* $u, v$ — вершини;
* $c$ — номер кольору від $0$ до $N$.
* Значення `-1` означає, що колір $c$ у вершини $u$ вільний.

Ця структура дозволяє за час $O(1)$ отримувати доступ до суміжних вершин за кольором, що критично для швидкої роботи ланцюгів Кемпе. Недоліком є використання пам'яті $O(N^2)$. Оптимізація до $O(N \cdot \Delta)$ можлива, але вимагає попереднього обчислення $\Delta$ або динамічного розширення матриці.

Метод `void add_edge(int u, int v)` додає ребро, спершу обираючи перший вільний колір, а при конфлікті застосовує інверсію:

```cpp
for (int i = 0; i < adj_matrix[0].size(); i++) {
    if (adj_matrix[u][i] == -1 && free_colour_1 == -1) {
        free_colour_1 = i;
    }
    if (adj_matrix[v][i] == -1 && free_colour_2 == -1) {
        free_colour_2 = i;
    }
    if (free_colour_1 != -1 && free_colour_2 != -1) {
        break;
    }
}

invert_colours(v, free_colour_1, free_colour_2);
adj_matrix[u][free_colour_1] = v;
adj_matrix[v][free_colour_1] = u;
```

Метод ```void invert_colours(int start_node, int colour_1, int colour_2)``` реалізує перестановку кольорів уздовж ланцюга. 


### Складність алгоритмів


| Операція  | Часова складність | Просторова складність  |
| ------------- | ------------- | ------------- |
| Додавання ребра  | 	O(Δ) або O(N)  | -  |
| Інверсія Кемпе  | O(N  | -  |
| Загальна  | O(E⋅N)  | O(N )  |


### Результати тестування

Для генерації тестових даних використано скрипт `generator.py`. Порівняння проводилося з бібліотекою networkx за допомогою скрипта `python-networkx.py`


#### Загальний лог
 Nodes: 14, Edges: 16
  C++: 0.3452s, 0.08MB, Colors: 5
  NetworkX: 0.0055s, 0.08MB, Colors: 4
  Speedup: 62.23x (NetworkX is faster here)

Nodes: 108, Edges: 327
  C++: 0.2052s, 0.08MB, Colors: 43
  NetworkX: 0.0452s, 1.72MB, Colors: 43
  Speedup: 4.54x (NetworkX is faster)

Nodes: 200, Edges: 2985
  C++: 0.2777s, 0.27MB, Colors: 47
  NetworkX: 0.9918s, 21.66MB, Colors: 43
  Speedup: 0.28x (C++ is faster)

Nodes: 1032, Edges: 9620
  C++: 0.2706s, 0.90MB, Colors: 342
  NetworkX: 10.1780s, 327.35MB, Colors: 342
  Speedup: 0.03x (C++ is significantly faster)

#### Графіки

  <img width="4168" height="2966" alt="image" src="https://github.com/user-attachments/assets/438ece67-c0da-40bf-839e-060563fa1bdf" />


#### Аналіз 
- Час виконання: На малих графах C++ програє бібліотеці NetworkX через накладні витрати на ініціалізацію. Проте на великих графах (200-1000 вершин) C++ значно випереджає Python (наприклад, 0.27с проти 10.17с для 1000 вершин).
- Пам'ять: Алгоритм на C++ використовує в рази менше пам'яті. Навіть із матрицею N×N, споживання складає менше 1 МБ там, де NetworkX потребує понад 300 МБ (через важкі об'єкти Python).
- Точність: Спостерігається певна аномалія на малих графах, де жадібний алгоритм іноді знаходить на 1 колір більше за оптимальне значення, але на великих даних кількість кольорів збігається з еталонним рішенням NetworkX.
